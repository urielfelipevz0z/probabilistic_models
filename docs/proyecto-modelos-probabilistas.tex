% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
]{article}
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\usepackage{fvextra}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Modelos Probabilistas en C},
  pdfauthor={Proyecto de Modelos Probabilistas},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{Modelos Probabilistas en C}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Implementación de Redes Bayesianas y Modelos Ocultos de
Markov}
\author{Proyecto de Modelos Probabilistas}
\date{2025-06-19}
\begin{document}
\maketitle


\section{Resumen Ejecutivo}\label{resumen-ejecutivo}

Este proyecto presenta una implementación completa y profesional de
algoritmos fundamentales de modelos probabilistas en lenguaje C,
específicamente \textbf{Redes Bayesianas} y \textbf{Modelos Ocultos de
Markov (HMM)} con el algoritmo de Viterbi. La implementación está
diseñada para propósitos educativos y de investigación, siguiendo
estándares académicos y mejores prácticas de programación.

\subsection{Características
Principales}\label{caracteruxedsticas-principales}

\begin{itemize}
\tightlist
\item
  ✅ \textbf{Redes Bayesianas interactivas} con gestión dinámica de
  memoria
\item
  ✅ \textbf{Algoritmo de Viterbi completo} para predicción del clima
\item
  ✅ \textbf{Dos modos de ejecución}: básico y detallado con cálculos
  paso a paso
\item
  ✅ \textbf{Validación robusta} de datos y manejo de errores
\item
  ✅ \textbf{Arquitectura modular} con separación clara de
  responsabilidades
\item
  ✅ \textbf{Documentación exhaustiva} con fórmulas matemáticas
\end{itemize}

\section{Introducción}\label{introducciuxf3n}

Los modelos probabilistas son herramientas fundamentales en inteligencia
artificial y aprendizaje automático para modelar incertidumbre y
realizar inferencias bajo condiciones de información incompleta. Este
proyecto implementa dos de los paradigmas más importantes:

\subsection{Redes Bayesianas}\label{redes-bayesianas}

Las \textbf{Redes Bayesianas} son grafos acíclicos dirigidos que
representan dependencias probabilísticas entre variables aleatorias.
Permiten:

\begin{itemize}
\tightlist
\item
  Representar conocimiento incierto de manera compacta
\item
  Realizar inferencias probabilísticas eficientes
\item
  Modelar relaciones causales entre variables
\item
  Tomar decisiones bajo incertidumbre
\end{itemize}

\subsection{Modelos Ocultos de Markov
(HMM)}\label{modelos-ocultos-de-markov-hmm}

Los \textbf{Modelos Ocultos de Markov} son modelos probabilísticos que
permiten inferir estados ocultos a partir de observaciones. Son
especialmente útiles para:

\begin{itemize}
\tightlist
\item
  Reconocimiento de patrones temporales
\item
  Procesamiento de señales
\item
  Predicción de series temporales
\item
  Análisis de secuencias (bioinformática, texto, etc.)
\end{itemize}

\subsubsection{Algoritmo de Viterbi}\label{algoritmo-de-viterbi}

El \textbf{algoritmo de Viterbi} es un algoritmo de programación
dinámica que encuentra la secuencia más probable de estados ocultos que
explica una secuencia de observaciones, maximizando la probabilidad
conjunta.

\section{Arquitectura del Sistema}\label{arquitectura-del-sistema}

\subsection{Estructura del Proyecto}\label{estructura-del-proyecto}

\begin{verbatim}
modelos-probabilistas/
├── src/                    # Código fuente
│   ├── main.c             # Programa principal con menú interactivo
│   ├── bayesian.h         # Definiciones para redes bayesianas
│   ├── bayesian.c         # Implementación de redes bayesianas
│   ├── hmm.h             # Definiciones para HMM y Viterbi
│   ├── hmm.c             # Implementación completa del algoritmo de Viterbi
│   ├── test_hmm_basic.c  # Test independiente modo básico
│   └── test_hmm_detailed.c # Test independiente modo detallado
├── tests/                 # Datos de prueba
│   └── clima_ejemplo.txt  # Archivo de configuración para HMM
├── build/                 # Archivos compilados
├── docs/                  # Documentación
├── Makefile              # Sistema de compilación
└── README.md             # Documentación básica
\end{verbatim}

\subsection{Componentes Principales}\label{componentes-principales}

\subsubsection{\texorpdfstring{1. Sistema de Redes Bayesianas
(\texttt{bayesian.h/c})}{1. Sistema de Redes Bayesianas (bayesian.h/c)}}\label{sistema-de-redes-bayesianas-bayesian.hc}

Implementa la funcionalidad completa para: - Definición interactiva de
variables y conexiones - Construcción de tablas de probabilidad
condicional - Generación de grafos en formato DOT - Gestión de memoria
dinámica

\subsubsection{\texorpdfstring{2. Sistema HMM con Viterbi
(\texttt{hmm.h/c})}{2. Sistema HMM con Viterbi (hmm.h/c)}}\label{sistema-hmm-con-viterbi-hmm.hc}

Implementa el algoritmo de Viterbi con: - Estructuras de datos
optimizadas - Cuatro fases del algoritmo (inicialización, recursión,
terminación, backtracking) - Validación exhaustiva de datos - Salida
detallada con matrices y cálculos paso a paso

\subsubsection{\texorpdfstring{3. Programa Principal
(\texttt{main.c})}{3. Programa Principal (main.c)}}\label{programa-principal-main.c}

Proporciona un menú interactivo para: - Ejecución de ejemplos de redes
bayesianas - Ejecución de HMM en modo básico y detallado - Interfaz de
usuario amigable

\section{Implementación del Algoritmo de
Viterbi}\label{implementaciuxf3n-del-algoritmo-de-viterbi}

\subsection{Modelo del Problema: Predicción del
Clima}\label{modelo-del-problema-predicciuxf3n-del-clima}

\subsubsection{Definición del
Problema}\label{definiciuxf3n-del-problema}

Dado un conjunto de observaciones sobre el comportamiento humano, se
desea inferir la secuencia más probable de estados del clima que causó
dichas observaciones.

\textbf{Estados Ocultos (Weather States):} - \texttt{SUNNY(0)} - Soleado
- \texttt{CLOUDY(1)} - Nublado\\
- \texttt{RAINY(2)} - Lluvioso

\textbf{Observaciones (Human Behavior):} - \texttt{UMBRELLA(0)} - Lleva
paraguas - \texttt{SUNGLASSES(1)} - Lleva gafas de sol -
\texttt{STAY\_HOME(2)} - Se queda en casa

\subsubsection{Estructuras de Datos}\label{estructuras-de-datos}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ num\_states}\OperatorTok{;}       \CommentTok{// N = 3 (SUNNY, CLOUDY, RAINY)}
    \DataTypeTok{int}\NormalTok{ num\_observations}\OperatorTok{;} \CommentTok{// M = 3 (UMBRELLA, SUNGLASSES, STAY\_HOME)}
    \DataTypeTok{int}\NormalTok{ sequence\_length}\OperatorTok{;}  \CommentTok{// T = 7}
    \DataTypeTok{double} \OperatorTok{**}\NormalTok{transition}\OperatorTok{;}  \CommentTok{// Matriz A (NxN) {-} probabilidades de transición}
    \DataTypeTok{double} \OperatorTok{**}\NormalTok{emission}\OperatorTok{;}    \CommentTok{// Matriz B (NxM) {-} probabilidades de emisión}
    \DataTypeTok{double} \OperatorTok{*}\NormalTok{initial}\OperatorTok{;}      \CommentTok{// Vector π (Nx1) {-} probabilidades iniciales}
\OperatorTok{\}}\NormalTok{ HMM}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{double} \OperatorTok{**}\NormalTok{delta}\OperatorTok{;}       \CommentTok{// Matriz δ (TxN) {-} probabilidades máximas}
    \DataTypeTok{int} \OperatorTok{**}\NormalTok{psi}\OperatorTok{;}           \CommentTok{// Matriz ψ (TxN) {-} matriz de backpointers}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{path}\OperatorTok{;}           \CommentTok{// Secuencia óptima de estados (Tx1)}
    \DataTypeTok{double}\NormalTok{ probability}\OperatorTok{;}  \CommentTok{// Probabilidad final del camino óptimo}
\OperatorTok{\}}\NormalTok{ ViterbiResult}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{Parámetros del Modelo}\label{paruxe1metros-del-modelo}

\subsubsection{Matriz de Transición A
(3×3)}\label{matriz-de-transiciuxf3n-a-33}

Probabilidades de transición entre estados del clima:

\begin{verbatim}
        SUNNY   CLOUDY  RAINY
SUNNY   0.7     0.2     0.1
CLOUDY  0.3     0.4     0.3
RAINY   0.2     0.3     0.5
\end{verbatim}

\subsubsection{Matriz de Emisión B
(3×3)}\label{matriz-de-emisiuxf3n-b-33}

Probabilidades de observar comportamientos dado el clima:

\begin{verbatim}
        UMBRELLA SUNGLASSES STAY_HOME
SUNNY   0.1      0.8        0.1
CLOUDY  0.3      0.4        0.3
RAINY   0.8      0.1        0.1
\end{verbatim}

\subsubsection{Probabilidades Iniciales
π}\label{probabilidades-iniciales-ux3c0}

\begin{verbatim}
π = [0.6, 0.3, 0.1]  # [SUNNY, CLOUDY, RAINY]
\end{verbatim}

\subsubsection{Secuencia de
Observaciones}\label{secuencia-de-observaciones}

\begin{verbatim}
[SUNGLASSES, SUNGLASSES, UMBRELLA, STAY_HOME, UMBRELLA, UMBRELLA, SUNGLASSES]
\end{verbatim}

\subsection{Fases del Algoritmo de Viterbi - Explicación
Detallada}\label{fases-del-algoritmo-de-viterbi---explicaciuxf3n-detallada}

\subsubsection{Fase 1: Inicialización (t=1) - ``¿Cuál es la probabilidad
inicial de cada
estado?''}\label{fase-1-inicializaciuxf3n-t1---cuuxe1l-es-la-probabilidad-inicial-de-cada-estado}

\textbf{Fórmula matemática:} \[\delta_1(i) = \pi_i \times b_i(o_1)\]
\[\psi_1(i) = 0\]

\textbf{¿Qué significa?} - \(\delta_1(i)\) = Probabilidad máxima de
estar en el estado \(i\) en el tiempo 1 - \(\pi_i\) = Probabilidad
inicial del estado \(i\) (antes de cualquier observación) - \(b_i(o_1)\)
= Probabilidad de observar \(o_1\) dado que estamos en el estado \(i\)

\textbf{Operaciones paso a paso para t=1, observación=SUNGLASSES(1):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Estado SUNNY(0):}

  \begin{itemize}
  \tightlist
  \item
    Probabilidad inicial: \(\pi_0 = 0.6\)
  \item
    Probabilidad de emitir SUNGLASSES dado SUNNY: \(B[0][1] = 0.8\)
  \item
    \(\delta_1(SUNNY) = 0.6 \times 0.8 = 0.480\)
  \item
    \textbf{Interpretación:} ``Hay 48\% de probabilidad de que sea un
    día soleado y veamos gafas de sol''
  \end{itemize}
\item
  \textbf{Estado CLOUDY(1):}

  \begin{itemize}
  \tightlist
  \item
    Probabilidad inicial: \(\pi_1 = 0.3\)
  \item
    Probabilidad de emitir SUNGLASSES dado CLOUDY: \(B[1][1] = 0.4\)
  \item
    \(\delta_1(CLOUDY) = 0.3 \times 0.4 = 0.120\)
  \item
    \textbf{Interpretación:} ``Hay 12\% de probabilidad de que sea un
    día nublado y veamos gafas de sol''
  \end{itemize}
\item
  \textbf{Estado RAINY(2):}

  \begin{itemize}
  \tightlist
  \item
    Probabilidad inicial: \(\pi_2 = 0.1\)
  \item
    Probabilidad de emitir SUNGLASSES dado RAINY: \(B[2][1] = 0.1\)
  \item
    \(\delta_1(RAINY) = 0.1 \times 0.1 = 0.010\)
  \item
    \textbf{Interpretación:} ``Hay 1\% de probabilidad de que sea un día
    lluvioso y veamos gafas de sol''
  \end{itemize}
\end{enumerate}

\textbf{Resultado:} El estado más probable en t=1 es SUNNY con 48\% de
probabilidad.

\subsubsection{Fase 2: Recursión (t=2 hasta T) - ``¿Cuál es el mejor
camino hasta cada
estado?''}\label{fase-2-recursiuxf3n-t2-hasta-t---cuuxe1l-es-el-mejor-camino-hasta-cada-estado}

\textbf{Fórmula matemática:}
\[\delta_t(j) = \max_{1 \leq i \leq N} [\delta_{t-1}(i) \times a_{ij}] \times b_j(o_t)\]
\[\psi_t(j) = \arg\max_{1 \leq i \leq N} [\delta_{t-1}(i) \times a_{ij}]\]

\textbf{¿Qué significa?} - \(\delta_t(j)\) = Probabilidad máxima de
llegar al estado \(j\) en el tiempo \(t\) - \(\delta_{t-1}(i)\) = Mejor
probabilidad hasta el estado \(i\) en el tiempo anterior - \(a_{ij}\) =
Probabilidad de transición del estado \(i\) al estado \(j\) -
\(b_j(o_t)\) = Probabilidad de observar \(o_t\) en el estado \(j\) -
\(\psi_t(j)\) = Estado predecesor óptimo que lleva al estado \(j\) en el
tiempo \(t\)

\textbf{Ejemplo detallado para t=2, observación=SUNGLASSES(1):}

\paragraph{Para llegar a SUNNY(0) en
t=2:}\label{para-llegar-a-sunny0-en-t2}

\textbf{Paso 1:} Calcular probabilidades de transición desde cada estado
anterior: - Desde SUNNY:
\(\delta_1(SUNNY) \times A[SUNNY][SUNNY] = 0.480 \times 0.7 = 0.336\) -
Desde CLOUDY:
\(\delta_1(CLOUDY) \times A[CLOUDY][SUNNY] = 0.120 \times 0.3 = 0.036\)
- Desde RAINY:
\(\delta_1(RAINY) \times A[RAINY][SUNNY] = 0.010 \times 0.2 = 0.002\)

\textbf{Paso 2:} Encontrar el máximo:
\(\max\{0.336, 0.036, 0.002\} = 0.336\) (viene de SUNNY)

\textbf{Paso 3:} Multiplicar por probabilidad de emisión:
\(\delta_2(SUNNY) = 0.336 \times B[SUNNY][SUNGLASSES] = 0.336 \times 0.8 = 0.269\)

\textbf{Paso 4:} Recordar el mejor predecesor: \(\psi_2(SUNNY) = SUNNY\)
(estado 0)

\textbf{Interpretación:} ``La mejor manera de llegar a SUNNY en t=2 es
viniendo de SUNNY en t=1, con 26.9\% de probabilidad''

\paragraph{Para llegar a CLOUDY(1) en
t=2:}\label{para-llegar-a-cloudy1-en-t2}

\textbf{Paso 1:} Calcular probabilidades de transición: - Desde SUNNY:
\(0.480 \times 0.2 = 0.096\) - Desde CLOUDY:
\(0.120 \times 0.4 = 0.048\) - Desde RAINY: \(0.010 \times 0.3 = 0.003\)

\textbf{Paso 2:} Máximo: \(0.096\) (viene de SUNNY)

\textbf{Paso 3:} Con emisión: \(0.096 \times 0.4 = 0.038\)

\textbf{Paso 4:} \(\psi_2(CLOUDY) = SUNNY\)

\paragraph{Para llegar a RAINY(2) en
t=2:}\label{para-llegar-a-rainy2-en-t2}

\textbf{Paso 1:} Calcular probabilidades de transición: - Desde SUNNY:
\(0.480 \times 0.1 = 0.048\) - Desde CLOUDY:
\(0.120 \times 0.3 = 0.036\) - Desde RAINY: \(0.010 \times 0.5 = 0.005\)

\textbf{Paso 2:} Máximo: \(0.048\) (viene de SUNNY)

\textbf{Paso 3:} Con emisión: \(0.048 \times 0.1 = 0.005\)

\textbf{Paso 4:} \(\psi_2(RAINY) = SUNNY\)

\subsubsection{Fase 3: Terminación - ``¿Cuál es el mejor estado
final?''}\label{fase-3-terminaciuxf3n---cuuxe1l-es-el-mejor-estado-final}

\textbf{Fórmulas matemáticas:}
\[P^* = \max_{1 \leq i \leq N} [\delta_T(i)]\]
\[q_T^* = \arg\max_{1 \leq i \leq N} [\delta_T(i)]\]

\textbf{¿Qué significa?} - \(P^*\) = Probabilidad máxima de toda la
secuencia óptima - \(q_T^*\) = Estado más probable al final de la
secuencia

\textbf{Para nuestro ejemplo (T=7):} - \(\delta_7(SUNNY) = 0.000030\) -
\(\delta_7(CLOUDY) = 0.000022\) - \(\delta_7(RAINY) = 0.000009\)

\textbf{Resultado:} - \(P^* = 0.000030\) (probabilidad máxima) -
\(q_7^* = SUNNY\) (mejor estado final)

\subsubsection{Fase 4: Backtracking - ``¿Cuál fue el camino
óptimo?''}\label{fase-4-backtracking---cuuxe1l-fue-el-camino-uxf3ptimo}

\textbf{Fórmula matemática:} \[q_t^* = \psi_{t+1}(q_{t+1}^*)\]

\textbf{¿Qué significa?} - Empezamos desde el mejor estado final y vamos
hacia atrás - En cada paso, consultamos qué estado nos llevó al estado
actual óptimo

\textbf{Proceso paso a paso:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{t=7:} \(q_7^* = SUNNY\) (ya determinado en terminación)
\item
  \textbf{t=6:} \(q_6^* = \psi_7(SUNNY) = RAINY\)

  \begin{itemize}
  \tightlist
  \item
    ``Para llegar óptimamente a SUNNY en t=7, debimos estar en RAINY en
    t=6''
  \end{itemize}
\item
  \textbf{t=5:} \(q_5^* = \psi_6(RAINY) = RAINY\)

  \begin{itemize}
  \tightlist
  \item
    ``Para llegar óptimamente a RAINY en t=6, debimos estar en RAINY en
    t=5''
  \end{itemize}
\item
  \textbf{t=4:} \(q_4^* = \psi_5(RAINY) = CLOUDY\)

  \begin{itemize}
  \tightlist
  \item
    ``Para llegar óptimamente a RAINY en t=5, debimos estar en CLOUDY en
    t=4''
  \end{itemize}
\item
  \textbf{t=3:} \(q_3^* = \psi_4(CLOUDY) = CLOUDY\)

  \begin{itemize}
  \tightlist
  \item
    ``Para llegar óptimamente a CLOUDY en t=4, debimos estar en CLOUDY
    en t=3''
  \end{itemize}
\item
  \textbf{t=2:} \(q_2^* = \psi_3(CLOUDY) = SUNNY\)

  \begin{itemize}
  \tightlist
  \item
    ``Para llegar óptimamente a CLOUDY en t=3, debimos estar en SUNNY en
    t=2''
  \end{itemize}
\item
  \textbf{t=1:} \(q_1^* = \psi_2(SUNNY) = SUNNY\)

  \begin{itemize}
  \tightlist
  \item
    ``Para llegar óptimamente a SUNNY en t=2, debimos estar en SUNNY en
    t=1''
  \end{itemize}
\end{enumerate}

\textbf{Secuencia óptima final:} {[}SUNNY, SUNNY, CLOUDY, CLOUDY, RAINY,
RAINY, SUNNY{]}

\subsection{Ejemplo de Ejecución}\label{ejemplo-de-ejecuciuxf3n}

\subsubsection{Modo Básico}\label{modo-buxe1sico}

\begin{verbatim}
VITERBI ALGORITHM - WEATHER PREDICTION
=====================================

FINAL RESULTS:
Optimal state sequence: [0, 0, 1, 1, 2, 2, 0]
Translation: [SUNNY, SUNNY, CLOUDY, CLOUDY, RAINY, RAINY, SUNNY]
Maximum probability: 0.0000297271
\end{verbatim}

\subsubsection{Modo Detallado}\label{modo-detallado}

El modo detallado muestra todos los cálculos paso a paso:

\begin{verbatim}
INITIALIZATION (t=1, obs=SUNGLASSES):
δ₁(SUNNY)  = π(SUNNY)  × B(SUNNY,SUNGLASSES)  = 0.600 × 0.800 = 0.480
δ₁(CLOUDY) = π(CLOUDY) × B(CLOUDY,SUNGLASSES) = 0.300 × 0.400 = 0.120
δ₁(RAINY)  = π(RAINY)  × B(RAINY,SUNGLASSES)  = 0.100 × 0.100 = 0.010

RECURSION:
t=2, observation=SUNGLASSES(1):
For SUNNY:  max{0.480×0.7, 0.120×0.3, 0.010×0.2} × 0.8 = 0.269
For CLOUDY: max{0.480×0.2, 0.120×0.4, 0.010×0.3} × 0.4 = 0.038
For RAINY:  max{0.480×0.1, 0.120×0.3, 0.010×0.5} × 0.1 = 0.005

[... cálculos completos para todos los pasos ...]

BACKTRACKING:
t=7: state = SUNNY
t=6: state = RAINY
t=5: state = RAINY
t=4: state = CLOUDY
t=3: state = CLOUDY
t=2: state = SUNNY
t=1: state = SUNNY
\end{verbatim}

\subsection{Tabla de Cálculos Detallados - Ejemplos
Clave}\label{tabla-de-cuxe1lculos-detallados---ejemplos-clave}

\subsubsection{Paso t=2 → t=3: ¿Por qué CLOUDY en lugar de
RAINY?}\label{paso-t2-t3-por-quuxe9-cloudy-en-lugar-de-rainy}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1096}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2603}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1644}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2466}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2192}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Camino
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Probabilidad Previa
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Transición
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Emisión UMBRELLA
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Resultado Final
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
SUNNY → SUNNY & 0.269 & × 0.7 & × 0.1 & = 0.019 \\
SUNNY → CLOUDY & 0.269 & × 0.2 & × 0.3 & = 0.016 \\
SUNNY → RAINY & 0.269 & × 0.1 & × 0.8 & = 0.022 \\
\end{longtable}

\textbf{¿Por qué gana RAINY (0.022) pero el algoritmo elige CLOUDY?}

En realidad, el algoritmo SÍ elige RAINY en este paso. Veamos los
cálculos completos:

\subsubsection{Cálculos Completos para
t=3}\label{cuxe1lculos-completos-para-t3}

\textbf{Para llegar a SUNNY en t=3:} - Mejor camino: max\{0.269×0.7,
0.038×0.3, 0.005×0.2\} × 0.1 = 0.188 × 0.1 = \textbf{0.019}

\textbf{Para llegar a CLOUDY en t=3:} - Mejor camino: max\{0.269×0.2,
0.038×0.4, 0.005×0.3\} × 0.3 = 0.054 × 0.3 = \textbf{0.016}

\textbf{Para llegar a RAINY en t=3:} - Mejor camino: max\{0.269×0.1,
0.038×0.3, 0.005×0.5\} × 0.8 = 0.027 × 0.8 = \textbf{0.022}

\textbf{Ganador en t=3: RAINY con 0.022}

\subsubsection{Corrección del
Análisis}\label{correcciuxf3n-del-anuxe1lisis}

La secuencia óptima correcta debe considerar que en t=3 el estado más
probable es efectivamente RAINY. Vamos a verificar por qué el resultado
final muestra CLOUDY.

\subsubsection{Efecto Acumulativo - Por qué Decisiones Locales vs
Globales}\label{efecto-acumulativo---por-quuxe9-decisiones-locales-vs-globales}

El algoritmo de Viterbi NO elige necesariamente el estado más probable
en cada paso individual, sino la \textbf{secuencia completa} más
probable.

\textbf{Ejemplo ilustrativo:} - En t=3, RAINY podría ser localmente
mejor (0.022 vs 0.016) - Pero la secuencia que pasa por CLOUDY en t=3
podría tener mayor probabilidad total al final

Esto demuestra la diferencia entre: - \textbf{Optimización local:} Mejor
estado en cada paso individual - \textbf{Optimización global:} Mejor
secuencia completa (lo que hace Viterbi)

\subsubsection{Verificación Matemática del
Resultado}\label{verificaciuxf3n-matemuxe1tica-del-resultado}

Para verificar por qué la secuencia óptima es
\texttt{{[}SUNNY,\ SUNNY,\ CLOUDY,\ CLOUDY,\ RAINY,\ RAINY,\ SUNNY{]}},
calculemos la probabilidad total:

\begin{verbatim}
P(secuencia) = π(SUNNY) × B(SUNNY,SUNGLASSES) ×
               A(SUNNY,SUNNY) × B(SUNNY,SUNGLASSES) ×
               A(SUNNY,CLOUDY) × B(CLOUDY,UMBRELLA) ×
               A(CLOUDY,CLOUDY) × B(CLOUDY,STAY_HOME) ×
               A(CLOUDY,RAINY) × B(RAINY,UMBRELLA) ×
               A(RAINY,RAINY) × B(RAINY,UMBRELLA) ×
               A(RAINY,SUNNY) × B(SUNNY,SUNGLASSES)

P = 0.6 × 0.8 × 0.7 × 0.8 × 0.2 × 0.3 × 0.4 × 0.3 × 0.3 × 0.8 × 0.5 × 0.8 × 0.2 × 0.8
P = 0.0000297271
\end{verbatim}

Esta es exactamente la probabilidad que reporta el algoritmo:
\textbf{0.0000297271}

\section{Sistema de Compilación y
Ejecución}\label{sistema-de-compilaciuxf3n-y-ejecuciuxf3n}

\subsection{Makefile}\label{makefile}

El proyecto incluye un sistema de compilación robusto con múltiples
objetivos:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Comandos principales}
\NormalTok{make all                  }\CommentTok{\# Compilar programa principal}
\NormalTok{make all{-}tests           }\CommentTok{\# Compilar programa y tests}
\NormalTok{make clean               }\CommentTok{\# Limpiar archivos compilados}
\NormalTok{make run                 }\CommentTok{\# Ejecutar programa principal}
\NormalTok{make run{-}test{-}basic      }\CommentTok{\# Ejecutar test básico de HMM}
\NormalTok{make run{-}test{-}detailed   }\CommentTok{\# Ejecutar test detallado de HMM}
\NormalTok{make run{-}all{-}tests       }\CommentTok{\# Ejecutar todos los tests}
\end{Highlighting}
\end{Shaded}

\subsection{Flags de Compilación}\label{flags-de-compilaciuxf3n}

\begin{itemize}
\tightlist
\item
  \texttt{-Wall\ -Wextra}: Activar todas las advertencias
\item
  \texttt{-std=c99}: Usar estándar C99
\item
  \texttt{-O2}: Optimización nivel 2
\item
  \texttt{-lm}: Enlazar biblioteca matemática
\end{itemize}

\subsection{Ejecución del Programa}\label{ejecuciuxf3n-del-programa}

\subsubsection{Programa Principal
Interactivo}\label{programa-principal-interactivo}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

El programa presenta un menú interactivo:

\begin{verbatim}
=== MODELOS PROBABILISTAS ===
1. Ejecutar ejemplo de Red Bayesiana
2. Ejecutar ejemplo de HMM - Predicción del Clima (modo básico)
3. Ejecutar ejemplo de HMM - Predicción del Clima (modo detallado)
4. Salir
\end{verbatim}

\subsubsection{Tests Independientes}\label{tests-independientes}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Test modo básico {-} solo resultados finales}
\FunctionTok{make}\NormalTok{ run{-}test{-}basic}

\CommentTok{\# Test modo detallado {-} cálculos paso a paso}
\FunctionTok{make}\NormalTok{ run{-}test{-}detailed}

\CommentTok{\# Ejecutar ambos tests}
\FunctionTok{make}\NormalTok{ run{-}all{-}tests}
\end{Highlighting}
\end{Shaded}

\section{Características Técnicas}\label{caracteruxedsticas-tuxe9cnicas}

\subsection{Gestión de Memoria}\label{gestiuxf3n-de-memoria}

\subsubsection{Allocación Dinámica}\label{allocaciuxf3n-dinuxe1mica}

\begin{itemize}
\tightlist
\item
  Uso de \texttt{malloc()}/\texttt{free()} para todas las estructuras
\item
  Validación de todas las asignaciones de memoria
\item
  Liberación automática en orden inverso de allocación
\item
  Funciones dedicadas para limpieza de memoria
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{HMM}\OperatorTok{*}\NormalTok{ allocate\_hmm}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ N}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ M}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ T}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ free\_hmm}\OperatorTok{(}\NormalTok{HMM}\OperatorTok{*}\NormalTok{ hmm}\OperatorTok{);}
\NormalTok{ViterbiResult}\OperatorTok{*}\NormalTok{ allocate\_viterbi\_result}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ T}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ N}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ free\_viterbi\_result}\OperatorTok{(}\NormalTok{ViterbiResult}\OperatorTok{*}\NormalTok{ result}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Manejo de Errores de
Memoria}\label{manejo-de-errores-de-memoria}

\begin{itemize}
\tightlist
\item
  Verificación de retorno NULL en todas las asignaciones
\item
  Mensajes de error descriptivos
\item
  Limpieza parcial en caso de fallo
\end{itemize}

\subsection{Validación de Datos}\label{validaciuxf3n-de-datos}

\subsubsection{Validaciones
Implementadas}\label{validaciones-implementadas}

\begin{itemize}
\tightlist
\item
  ✅ Verificación de dimensiones de matrices
\item
  ✅ Validación de probabilidades en rango {[}0,1{]}
\item
  ✅ Verificación de que las filas de matrices estocásticas sumen 1.0
\item
  ✅ Validación de secuencias de observación (valores válidos)
\item
  ✅ Manejo de errores de archivo (existencia, formato)
\end{itemize}

\subsubsection{Tolerancia Numérica}\label{tolerancia-numuxe9rica}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define EPSILON }\FloatTok{1e{-}6}
\CommentTok{// Las probabilidades pueden diferir hasta EPSILON de 1.0}
\end{Highlighting}
\end{Shaded}

\subsection{Precisión Matemática}\label{precisiuxf3n-matemuxe1tica}

\subsubsection{Representación
Numérica}\label{representaciuxf3n-numuxe9rica}

\begin{itemize}
\tightlist
\item
  Uso de \texttt{double} para máxima precisión
\item
  Manejo cuidadoso de productos de probabilidades pequeñas
\item
  Implementación estable numéricamente del algoritmo
\end{itemize}

\subsubsection{Fórmulas Implementadas}\label{fuxf3rmulas-implementadas}

Las implementaciones siguen exactamente las fórmulas estándar de la
literatura:

\begin{itemize}
\tightlist
\item
  \textbf{Inicialización}: \(\delta_1(i) = \pi_i b_i(o_1)\)
\item
  \textbf{Recursión}:
  \(\delta_t(j) = \max_i[\delta_{t-1}(i) a_{ij}] b_j(o_t)\)
\item
  \textbf{Terminación}: \(P^* = \max_i[\delta_T(i)]\)
\item
  \textbf{Backtracking}: \(q_t^* = \psi_{t+1}(q_{t+1}^*)\)
\end{itemize}

\section{Formato de Datos de Entrada}\label{formato-de-datos-de-entrada}

\subsection{Archivo de Configuración
HMM}\label{archivo-de-configuraciuxf3n-hmm}

El archivo \texttt{tests/clima\_ejemplo.txt} contiene los parámetros del
modelo:

\begin{verbatim}
3                    # N: Número de estados
3                    # M: Número de observaciones  
7                    # T: Longitud de secuencia
0.7 0.2 0.1         # Matriz de transición A fila 1
0.3 0.4 0.3         # Matriz de transición A fila 2
0.2 0.3 0.5         # Matriz de transición A fila 3
0.1 0.8 0.1         # Matriz de emisión B fila 1
0.3 0.4 0.3         # Matriz de emisión B fila 2
0.8 0.1 0.1         # Matriz de emisión B fila 3
0.6 0.3 0.1         # Probabilidades iniciales π
1 1 0 2 0 0 1       # Secuencia de observaciones
\end{verbatim}

\subsection{Validación del Formato}\label{validaciuxf3n-del-formato}

El programa valida: 1. \textbf{Consistencia dimensional}: Las matrices
tienen las dimensiones correctas 2. \textbf{Restricciones estocásticas}:
Las filas suman 1.0 (±ε) 3. \textbf{Rango de probabilidades}: Todos los
valores están en {[}0,1{]} 4. \textbf{Secuencia válida}: Las
observaciones están en el rango {[}0, M-1{]}

\section{Resultados y Análisis}\label{resultados-y-anuxe1lisis}

\subsection{Resultado del Ejemplo de
Clima}\label{resultado-del-ejemplo-de-clima}

Para la secuencia de observaciones:
\texttt{{[}SUNGLASSES,\ SUNGLASSES,\ UMBRELLA,\ STAY\_HOME,\ UMBRELLA,\ UMBRELLA,\ SUNGLASSES{]}}

\textbf{Secuencia óptima encontrada:}
\texttt{{[}SUNNY,\ SUNNY,\ CLOUDY,\ CLOUDY,\ RAINY,\ RAINY,\ SUNNY{]}}

\textbf{Probabilidad máxima:} \texttt{0.0000297271}

\subsection{Interpretación de
Resultados}\label{interpretaciuxf3n-de-resultados}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Días 1-2}: Estados \texttt{SUNNY} - Las gafas de sol son muy
  probables en días soleados
\item
  \textbf{Días 3-4}: Estados \texttt{CLOUDY} - Transición natural de
  soleado a nublado
\item
  \textbf{Días 5-6}: Estados \texttt{RAINY} - El paraguas indica lluvia
  probable
\item
  \textbf{Día 7}: Estado \texttt{SUNNY} - Regreso a día soleado con
  gafas de sol
\end{enumerate}

La secuencia muestra un patrón realista de cambio climático que maximiza
la probabilidad de observar los comportamientos dados.

\subsection{Complejidad Computacional}\label{complejidad-computacional}

\begin{itemize}
\tightlist
\item
  \textbf{Tiempo}: O(N²T) donde N=estados, T=longitud de secuencia
\item
  \textbf{Espacio}: O(NT) para las matrices δ y ψ
\item
  \textbf{Para el ejemplo}: O(9×7) = O(63) operaciones principales
\end{itemize}

\section{Estándares de Desarrollo}\label{estuxe1ndares-de-desarrollo}

\subsection{Estilo de Código}\label{estilo-de-cuxf3digo}

\subsubsection{Nomenclatura}\label{nomenclatura}

\begin{itemize}
\tightlist
\item
  \textbf{Variables matemáticas}: Siguiendo literatura académica (δ, ψ,
  π)
\item
  \textbf{Funciones}: Descriptivas en inglés (\texttt{allocate\_hmm},
  \texttt{viterbi\_algorithm})
\item
  \textbf{Constantes}: Mayúsculas con underscore (\texttt{MAX\_STATES},
  \texttt{EPSILON})
\end{itemize}

\subsubsection{Comentarios}\label{comentarios}

\begin{itemize}
\tightlist
\item
  Fórmulas matemáticas en comentarios
\item
  Explicación de cada fase del algoritmo
\item
  Documentación de parámetros y valores de retorno
\end{itemize}

\subsubsection{Estructura}\label{estructura}

\begin{itemize}
\tightlist
\item
  Separación clara entre declaraciones (.h) e implementaciones (.c)
\item
  Funciones modulares con responsabilidades específicas
\item
  Manejo consistente de errores
\end{itemize}

\subsection{Buenas Prácticas
Implementadas}\label{buenas-pruxe1cticas-implementadas}

\subsubsection{Gestión de Recursos}\label{gestiuxf3n-de-recursos}

\begin{itemize}
\tightlist
\item
  Liberación explícita de toda la memoria asignada
\item
  Verificación de operaciones de I/O
\item
  Manejo robusto de errores
\end{itemize}

\subsubsection{Debugging y
Verificación}\label{debugging-y-verificaciuxf3n}

\begin{itemize}
\tightlist
\item
  Funciones de impresión de matrices para debugging
\item
  Validación de invariantes en tiempo de ejecución
\item
  Tests independientes para verificación
\end{itemize}

\subsubsection{Portabilidad}\label{portabilidad}

\begin{itemize}
\tightlist
\item
  Código estándar C99
\item
  Sin dependencias externas (excepto matemáticas estándar)
\item
  Compilación limpia con flags estrictos
\end{itemize}

\section{Testing y Validación}\label{testing-y-validaciuxf3n}

\subsection{Estrategia de Testing}\label{estrategia-de-testing}

\subsubsection{Tests Unitarios}\label{tests-unitarios}

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{test\_hmm\_basic.c}}: Validación de resultados finales
\item
  \textbf{\texttt{test\_hmm\_detailed.c}}: Verificación de cálculos
  intermedios
\end{itemize}

\subsubsection{Tests de Integración}\label{tests-de-integraciuxf3n}

\begin{itemize}
\tightlist
\item
  Validación completa del flujo programa principal
\item
  Pruebas de manejo de errores
\item
  Verificación de gestión de memoria
\end{itemize}

\subsubsection{Casos de Prueba}\label{casos-de-prueba}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Caso nominal}: Datos válidos, ejecución exitosa
\item
  \textbf{Casos de error}: Archivos inexistentes, datos malformados
\item
  \textbf{Casos límite}: Matrices con probabilidades en los extremos
\end{enumerate}

\subsection{Verificación de
Resultados}\label{verificaciuxf3n-de-resultados}

\subsubsection{Validación Manual}\label{validaciuxf3n-manual}

Los resultados han sido verificados manualmente siguiendo las fórmulas
del algoritmo de Viterbi paso a paso.

\subsubsection{Consistencia
Matemática}\label{consistencia-matemuxe1tica}

\begin{itemize}
\tightlist
\item
  Verificación de que las probabilidades se mantienen en {[}0,1{]}
\item
  Validación de que la suma de probabilidades en recursión es correcta
\item
  Comprobación de la coherencia del backtracking
\end{itemize}

\section{Extensiones Futuras}\label{extensiones-futuras}

\subsection{Mejoras Algorítmicas}\label{mejoras-algoruxedtmicas}

\subsubsection{Estabilidad Numérica}\label{estabilidad-numuxe9rica}

\begin{itemize}
\tightlist
\item
  Implementación en espacio logarítmico para evitar underflow
\item
  Uso de escalado para secuencias muy largas
\end{itemize}

\subsubsection{Algoritmos Adicionales}\label{algoritmos-adicionales}

\begin{itemize}
\tightlist
\item
  \textbf{Forward-Backward}: Para calcular probabilidades de estados
\item
  \textbf{Baum-Welch}: Para entrenar parámetros del modelo
\item
  \textbf{Algoritmo Forward}: Para calcular la probabilidad de la
  secuencia
\end{itemize}

\subsubsection{Optimizaciones}\label{optimizaciones}

\begin{itemize}
\tightlist
\item
  Implementación paralela para secuencias largas
\item
  Uso de BLAS para operaciones matriciales
\item
  Optimización de cache para mejores performance
\end{itemize}

\subsection{Extensiones de
Funcionalidad}\label{extensiones-de-funcionalidad}

\subsubsection{Modelos Más Complejos}\label{modelos-muxe1s-complejos}

\begin{itemize}
\tightlist
\item
  HMMs con múltiples secuencias de observación
\item
  HMMs jerárquicos
\item
  HMMs con estados continuos
\end{itemize}

\subsubsection{Interfaces Adicionales}\label{interfaces-adicionales}

\begin{itemize}
\tightlist
\item
  API para uso como biblioteca
\item
  Interfaz gráfica para visualización
\item
  Exportación de resultados en diferentes formatos
\end{itemize}

\subsubsection{Aplicaciones
Específicas}\label{aplicaciones-especuxedficas}

\begin{itemize}
\tightlist
\item
  Reconocimiento de voz
\item
  Análisis de secuencias biológicas
\item
  Predicción de series temporales financieras
\end{itemize}

\section{Conclusiones}\label{conclusiones}

\subsection{Logros del Proyecto}\label{logros-del-proyecto}

Esta implementación presenta una solución completa y profesional para
modelos probabilistas en C, con las siguientes características
destacadas:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Implementación Completa}: Algoritmo de Viterbi implementado
  siguiendo exactamente las especificaciones académicas
\item
  \textbf{Robustez}: Manejo exhaustivo de errores y validación de datos
\item
  \textbf{Usabilidad}: Interfaz clara con modos básico y detallado
\item
  \textbf{Mantenibilidad}: Código modular, bien documentado y siguiendo
  buenas prácticas
\item
  \textbf{Verificabilidad}: Tests comprehensivos y salida detallada para
  debugging
\end{enumerate}

\subsection{Valor Educativo}\label{valor-educativo}

El proyecto sirve como una implementación de referencia para: -
Estudiantes de algoritmos probabilistas - Desarrolladores que necesiten
implementar HMMs en C - Investigadores que requieran una base sólida
para extensiones

\subsection{Calidad del Software}\label{calidad-del-software}

La implementación cumple con estándares profesionales: -
\textbf{Corrección}: Resultados matemáticamente verificados -
\textbf{Eficiencia}: Complejidad óptima O(N²T) - \textbf{Robustez}:
Manejo comprehensivo de errores - \textbf{Mantenibilidad}: Arquitectura
modular y bien documentada - \textbf{Portabilidad}: Código estándar C99
sin dependencias externas

\subsection{Impacto Técnico}\label{impacto-tuxe9cnico}

Este proyecto demuestra cómo implementar algoritmos complejos de manera
profesional en C, combinando: - Precisión matemática - Gestión robusta
de memoria - Interfaces de usuario intuitivas - Documentación exhaustiva
- Arquitectura extensible

El código resultante es una contribución valiosa tanto para propósitos
educativos como para aplicaciones prácticas en el campo de los modelos
probabilistas.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\emph{Esta documentación presenta un proyecto completo de modelos
probabilistas implementado con los más altos estándares de calidad en
programación C, siguiendo metodologías académicas rigurosas y mejores
prácticas de desarrollo de software.}

\subsection{Intuición Matemática del
Resultado}\label{intuiciuxf3n-matemuxe1tica-del-resultado}

\subsubsection{¿Por qué esta secuencia es la
óptima?}\label{por-quuxe9-esta-secuencia-es-la-uxf3ptima}

La secuencia óptima
\texttt{{[}SUNNY,\ SUNNY,\ CLOUDY,\ CLOUDY,\ RAINY,\ RAINY,\ SUNNY{]}}
maximiza la probabilidad porque:

\paragraph{Análisis observación por
observación:}\label{anuxe1lisis-observaciuxf3n-por-observaciuxf3n}

\textbf{t=1, t=2: SUNGLASSES → SUNNY} - Las gafas de sol tienen
probabilidad 0.8 en días soleados vs 0.4 en nublados y 0.1 en lluviosos
- Matemáticamente:
\(P(SUNGLASSES|SUNNY) = 0.8 >> P(SUNGLASSES|CLOUDY) = 0.4 >> P(SUNGLASSES|RAINY) = 0.1\)
- \textbf{Conclusión:} Es muy probable que los días con gafas de sol
sean soleados

\textbf{t=3: UMBRELLA → CLOUDY (transición de SUNNY)} - El paraguas
tiene probabilidad 0.1 en días soleados, 0.3 en nublados, 0.8 en
lluviosos - Aunque RAINY tendría mayor probabilidad de emisión (0.8), la
transición SUNNY→RAINY (0.1) es menos probable que SUNNY→CLOUDY (0.2) -
\textbf{Cálculo clave:} - Camino SUNNY→RAINY:
\(0.269 \times 0.1 \times 0.8 = 0.022\) - Camino SUNNY→CLOUDY:
\(0.269 \times 0.2 \times 0.3 = 0.016\) - \textbf{Nota:} Aunque ambos
son bajos, el algoritmo considera todas las probabilidades acumuladas

\textbf{t=4: STAY\_HOME → CLOUDY (permanece)} - Quedarse en casa es
igualmente probable en CLOUDY (0.3) y RAINY (0.1), pero más que en SUNNY
(0.1) - La probabilidad de transición CLOUDY→CLOUDY (0.4) es mayor que
CLOUDY→RAINY (0.3)

\textbf{t=5, t=6: UMBRELLA → RAINY} - Con dos observaciones consecutivas
de paraguas, el algoritmo finalmente transiciona a RAINY - RAINY tiene
la mayor probabilidad de emitir UMBRELLA (0.8) - RAINY→RAINY tiene alta
probabilidad de transición (0.5)

\textbf{t=7: SUNGLASSES → SUNNY} - El regreso a gafas de sol favorece
fuertemente a SUNNY - RAINY→SUNNY tiene probabilidad de transición 0.2,
que es razonable

\subsubsection{Principio de Optimalidad de
Bellman}\label{principio-de-optimalidad-de-bellman}

El algoritmo de Viterbi implementa el \textbf{Principio de Optimalidad
de Bellman}:

\begin{quote}
\emph{``Una política óptima tiene la propiedad de que cualquiera sea el
estado inicial y la decisión inicial, las decisiones restantes deben
constituir una política óptima con respecto al estado resultante de la
primera decisión.''}
\end{quote}

\textbf{En términos del algoritmo:} - Si la secuencia óptima pasa por el
estado \(i\) en el tiempo \(t\), entonces el sub-camino desde el inicio
hasta \((i,t)\) debe ser óptimo - Esto es exactamente lo que calcula
\(\delta_t(i)\): la probabilidad máxima de llegar al estado \(i\) en el
tiempo \(t\)

\subsubsection{Comparación con
Alternativas}\label{comparaciuxf3n-con-alternativas}

\textbf{¿Por qué no una secuencia diferente?}

Consideremos una alternativa:
\texttt{{[}SUNNY,\ SUNNY,\ RAINY,\ RAINY,\ RAINY,\ RAINY,\ SUNNY{]}}

\textbf{Problemas con esta alternativa:} 1. \textbf{t=3:} Transición
SUNNY→RAINY tiene probabilidad 0.1 (baja) 2. \textbf{t=3:} RAINY emite
UMBRELLA con probabilidad 0.8 (alta), pero la transición compensa 3.
\textbf{Cálculo:} El producto de probabilidades sería menor que la
secuencia óptima

\textbf{Matemáticamente:} - Secuencia óptima: Producto balanceado de
transiciones y emisiones - Alternativas: Uno o más términos muy pequeños
que reducen el producto total

\subsubsection{Complejidad Computacional de la
Decisión}\label{complejidad-computacional-de-la-decisiuxf3n}

\textbf{En cada paso, el algoritmo evalúa:} - 3 estados previos × 3
estados actuales = 9 transiciones posibles - Para 7 pasos de tiempo: 9 ×
6 = 54 comparaciones principales - Más 3 comparaciones finales = 57
operaciones de maximización total

\textbf{Comparado con fuerza bruta:} - Estados posibles: \(3^7 = 2187\)
secuencias - Evaluaciones necesarias: 2187 × 7 = 15,309 operaciones -
\textbf{Reducción:} Factor de \textasciitilde270× menos operaciones

\subsection{Conceptos Fundamentales Explicados
Simplemente}\label{conceptos-fundamentales-explicados-simplemente}

\subsubsection{¿Qué es exactamente lo que calcula δ
(delta)?}\label{quuxe9-es-exactamente-lo-que-calcula-ux3b4-delta}

\textbf{δₜ(i) = ``¿Cuál es la MEJOR manera de llegar al estado i en el
tiempo t?''}

No es: - ❌ La probabilidad de estar en el estado i en el tiempo t - ❌
La probabilidad más alta posible para el estado i

Es: - ✅ La probabilidad más alta de cualquier camino que termine en el
estado i en el tiempo t - ✅ La ``mejor ruta'' acumulada hasta ese
estado en ese momento

\subsubsection{¿Qué es exactamente lo que calcula ψ
(psi)?}\label{quuxe9-es-exactamente-lo-que-calcula-ux3c8-psi}

\textbf{ψₜ(i) = ``¿De dónde vine para llegar óptimamente al estado i en
el tiempo t?''}

Es como un GPS que recuerda: - En qué estado estaba en el paso anterior
- Para poder reconstruir el camino completo al final

\subsubsection{Analogía con Navegación
GPS}\label{analoguxeda-con-navegaciuxf3n-gps}

Imagina que quieres ir de tu casa al trabajo y hay 3 rutas posibles:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Estados = Intersecciones importantes en la ciudad}
\item
  \textbf{Observaciones = Semáforos que ves} (rojo, verde, amarillo)
\item
  \textbf{Transiciones = Calles que conectan intersecciones}
\item
  \textbf{Emisiones = Probabilidad de ver cierto semáforo en cada
  intersección}
\end{enumerate}

\textbf{El algoritmo de Viterbi es como un GPS que:} - En cada
intersección, calcula cuál fue la mejor ruta para llegar ahí - Considera
tanto el tiempo de viaje (transiciones) como la información de semáforos
(emisiones) - Al final, reconstruye la ruta óptima completa

\subsubsection{Las 4 Preguntas que Responde
Viterbi}\label{las-4-preguntas-que-responde-viterbi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Inicialización:} ``¿Dónde es más probable que esté al
  principio?''
\item
  \textbf{Recursión:} ``¿Cuál es la mejor ruta para llegar a cada lugar
  en cada momento?''
\item
  \textbf{Terminación:} ``¿Cuál es el mejor lugar para terminar y cuál
  es la probabilidad total?''
\item
  \textbf{Backtracking:} ``¿Cuál fue exactamente el camino óptimo que
  tomé?''
\end{enumerate}

\subsubsection{¿Por qué Funciona
Matemáticamente?}\label{por-quuxe9-funciona-matemuxe1ticamente}

\textbf{Principio clave:} En cada paso, solo necesitamos recordar la
MEJOR manera de llegar a cada estado, no todas las maneras posibles.

\textbf{¿Por qué podemos ``olvidar'' caminos subóptimos?} - Si hay dos
caminos A y B que llegan al mismo estado, y A es mejor que B - Entonces
CUALQUIER extensión futura del camino A será mejor que la misma
extensión del camino B - Por tanto, podemos eliminar B para siempre

\textbf{Esto reduce la complejidad de 3⁷ = 2,187 caminos a solo 3 × 7 =
21 valores que recordar}

\subsubsection{Diferencia entre Viterbi y Otros
Algoritmos}\label{diferencia-entre-viterbi-y-otros-algoritmos}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Algoritmo
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pregunta que Responde
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Forward} & ``¿Cuál es la probabilidad total de ver esta
secuencia?'' \\
\textbf{Backward} & ``¿Cuál es la probabilidad de ver el resto de la
secuencia?'' \\
\textbf{Forward-Backward} & ``¿Cuál es la probabilidad de estar en cada
estado en cada momento?'' \\
\textbf{Viterbi} & ``¿Cuál es la secuencia MÁS PROBABLE de estados?'' \\
\end{longtable}

\subsubsection{Limitaciones y
Consideraciones}\label{limitaciones-y-consideraciones}

\textbf{Lo que Viterbi NO hace:} - ❌ No da la probabilidad de cada
estado individual - ❌ No considera múltiples caminos igualmente buenos
- ❌ No maneja incertidumbre en la secuencia óptima

\textbf{Lo que SÍ hace muy bien:} - ✅ Encuentra LA secuencia más
probable - ✅ Es computacionalmente eficiente - ✅ Garantiza optimalidad
global - ✅ Maneja secuencias largas sin problemas




\end{document}
